From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Maya Matuszczyk <maccraft123mc@gmail.com>
Date: Thu, 19 Dec 2024 21:08:19 +0100
Subject: platform: arm64: Add driver for EC found in most X1E laptops

Currently it features only reporting that the AP is going to suspend,
which results in keyboard backlight turning off and the power LED
slowly blinking on the Lenovo Yoga Slim 7x.

Honor Magicbook Art 14 and Lenovo Yoga Slim 7x are known to have
firmware with extensions which would need appropriate handling.
For reverse engineering the firmware on them I have written a Rust
utility:

https://github.com/Maccraft123/it8987-qcom-tool.git

Signed-off-by: Maya Matuszczyk <maccraft123mc@gmail.com>
---
 MAINTAINERS                              |   6 +
 drivers/platform/arm64/Kconfig           |   8 ++
 drivers/platform/arm64/Makefile          |   1 +
 drivers/platform/arm64/qcom-x1e-it8987.c | 158 +++++++++++++++++++++++
 4 files changed, 173 insertions(+)
 create mode 100644 drivers/platform/arm64/qcom-x1e-it8987.c

diff --git a/MAINTAINERS b/MAINTAINERS
index c0b444e5fd5a..3f935a213999 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -20182,6 +20182,12 @@ L:	netdev@vger.kernel.org
 S:	Maintained
 F:	drivers/net/ipa/
 
+QCOM IT8987 EC DRIVER
+M:	Maya Matuszczyk <maccraft123mc@gmail.com>
+S:	Maintained
+F:	Documentation/devicetree/bindings/platform/qcom,x1e-it8987-ec.yaml
+F:	drivers/platform/arm64/qcom-x1e-it8987.c
+
 QEMU MACHINE EMULATOR AND VIRTUALIZER SUPPORT
 M:	Gabriel Somlo <somlo@cmu.edu>
 M:	"Michael S. Tsirkin" <mst@redhat.com>
diff --git a/drivers/platform/arm64/Kconfig b/drivers/platform/arm64/Kconfig
index 06288aebc559..680dbb530166 100644
--- a/drivers/platform/arm64/Kconfig
+++ b/drivers/platform/arm64/Kconfig
@@ -70,4 +70,12 @@ config EC_LENOVO_YOGA_C630
 
 	  Say M or Y here to include this support.
 
+config EC_QCOM_X1E_IT8987
+	tristate "Embedded Controller driver for most X1E80100 laptops"
+	depends on ARCH_QCOM || COMPILE_TEST
+	depends on I2C
+	help
+	  This driver currently supports reporting device suspend to the EC so it
+	  can take appropriate actions.
+
 endif # ARM64_PLATFORM_DEVICES
diff --git a/drivers/platform/arm64/Makefile b/drivers/platform/arm64/Makefile
index 46a99eba3264..662d0f0c66b0 100644
--- a/drivers/platform/arm64/Makefile
+++ b/drivers/platform/arm64/Makefile
@@ -8,3 +8,4 @@
 obj-$(CONFIG_EC_ACER_ASPIRE1)	+= acer-aspire1-ec.o
 obj-$(CONFIG_EC_HUAWEI_GAOKUN)	+= huawei-gaokun-ec.o
 obj-$(CONFIG_EC_LENOVO_YOGA_C630) += lenovo-yoga-c630.o
+obj-$(CONFIG_EC_QCOM_X1E_IT8987) += qcom-x1e-it8987.o
diff --git a/drivers/platform/arm64/qcom-x1e-it8987.c b/drivers/platform/arm64/qcom-x1e-it8987.c
new file mode 100644
index 000000000000..d27067d6326a
--- /dev/null
+++ b/drivers/platform/arm64/qcom-x1e-it8987.c
@@ -0,0 +1,158 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (c) 2024 Maya Matuszczyk <maccraft123mc@gmail.com>
+ */
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/input.h>
+#include <linux/input/sparse-keymap.h>
+
+#define EC_IRQ_REASON_REG 0x05
+#define EC_SUSPEND_RESUME_REG 0x23
+#define EC_IRQ_ENABLE_REG 0x35
+
+#define EC_NOTIFY_SUSPEND_ENTER 0x01
+#define EC_NOTIFY_SUSPEND_EXIT 0x00
+#define EC_NOTIFY_SCREEN_OFF 0x03
+#define EC_NOTIFY_SCREEN_ON 0x04
+
+#define EC_IRQ_MICMUTE_BUTTON 0x04
+#define EC_IRQ_FAN1_STATUS_CHANGE 0x30
+#define EC_IRQ_FAN2_STATUS_CHANGE 0x31
+#define EC_IRQ_FAN1_SPEED_CHANGE 0x32
+#define EC_IRQ_FAN2_SPEED_CHANGE 0x33
+#define EC_IRQ_COMPLETED_LUT_UPDATE 0x34
+#define EC_IRQ_COMPLETED_FAN_PROFILE_SWITCH 0x35
+#define EC_IRQ_THERMISTOR_1_TEMP_THRESHOLD_CROSS 0x36
+#define EC_IRQ_THERMISTOR_2_TEMP_THRESHOLD_CROSS 0x37
+#define EC_IRQ_THERMISTOR_3_TEMP_THRESHOLD_CROSS 0x38
+#define EC_IRQ_THERMISTOR_4_TEMP_THRESHOLD_CROSS 0x39
+#define EC_IRQ_THERMISTOR_5_TEMP_THRESHOLD_CROSS 0x3a
+#define EC_IRQ_THERMISTOR_6_TEMP_THRESHOLD_CROSS 0x3b
+#define EC_IRQ_THERMISTOR_7_TEMP_THRESHOLD_CROSS 0x3c
+#define EC_IRQ_RECOVERED_FROM_RESET 0x3d
+
+struct qcom_x1e_it8987_ec {
+	struct i2c_client *client;
+	struct input_dev *idev;
+	struct mutex lock;
+};
+
+static irqreturn_t qcom_x1e_it8987_ec_irq(int irq, void *data)
+{
+	struct qcom_x1e_it8987_ec *ec = data;
+	struct device *dev = &ec->client->dev;
+	int val;
+
+	guard(mutex)(&ec->lock);
+
+	val = i2c_smbus_read_byte_data(ec->client, EC_IRQ_REASON_REG);
+	if (val < 0) {
+		dev_err(dev, "Failed to get EC IRQ reason: %d\n", val);
+		return IRQ_HANDLED;
+	}
+
+	dev_info(dev, "Unhandled EC IRQ reason: %d\n", val);
+
+	return IRQ_HANDLED;
+}
+
+static int qcom_x1e_it8987_ec_probe(struct i2c_client *client)
+{
+	struct device *dev = &client->dev;
+	struct qcom_x1e_it8987_ec *ec;
+	int ret;
+
+	ec = devm_kzalloc(dev, sizeof(*ec), GFP_KERNEL);
+	if (!ec)
+		return -ENOMEM;
+
+	mutex_init(&ec->lock);
+	ec->client = client;
+
+	ret = devm_request_threaded_irq(dev, client->irq,
+					NULL, qcom_x1e_it8987_ec_irq,
+					IRQF_ONESHOT, "qcom_x1e_it8987_ec", ec);
+	if (ret < 0)
+		return dev_err_probe(dev, ret, "Unable to request irq\n");
+
+	ret = i2c_smbus_write_byte_data(client, EC_IRQ_ENABLE_REG, 0x01);
+	if (ret < 0)
+		return dev_err_probe(dev, ret, "Failed to enable interrupts\n");
+
+	return 0;
+}
+
+static void qcom_x1e_it8987_ec_remove(struct i2c_client *client)
+{
+	struct device *dev = &client->dev;
+	int ret;
+
+	ret = i2c_smbus_write_byte_data(client, EC_IRQ_ENABLE_REG, 0x00);
+	if (ret < 0)
+		dev_err(dev, "Failed to disable interrupts: %d\n", ret);
+}
+
+static int qcom_x1e_it8987_ec_suspend(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	int ret;
+
+	ret = i2c_smbus_write_byte_data(client, EC_SUSPEND_RESUME_REG, EC_NOTIFY_SCREEN_OFF);
+	if (ret)
+		return ret;
+
+	ret = i2c_smbus_write_byte_data(client, EC_SUSPEND_RESUME_REG, EC_NOTIFY_SUSPEND_ENTER);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static int qcom_x1e_it8987_ec_resume(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	int ret;
+
+	ret = i2c_smbus_write_byte_data(client, EC_SUSPEND_RESUME_REG, EC_NOTIFY_SUSPEND_EXIT);
+	if (ret)
+		return ret;
+
+	ret = i2c_smbus_write_byte_data(client, EC_SUSPEND_RESUME_REG, EC_NOTIFY_SCREEN_ON);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static const struct of_device_id qcom_x1e_it8987_ec_of_match[] = {
+	{ .compatible = "lenovo,yoga-slim7x-ec" },
+	{ .compatible = "qcom,x1e-it9897-ec" },
+	{}
+};
+MODULE_DEVICE_TABLE(of, qcom_x1e_it8987_ec_of_match);
+
+static const struct i2c_device_id qcom_x1e_it8987_ec_i2c_id_table[] = {
+	{ "qcom-x1e-it8987-ec", },
+	{}
+};
+MODULE_DEVICE_TABLE(i2c, qcom_x1e_it8987_ec_i2c_id_table);
+
+static DEFINE_SIMPLE_DEV_PM_OPS(qcom_x1e_it8987_ec_pm_ops,
+		qcom_x1e_it8987_ec_suspend,
+		qcom_x1e_it8987_ec_resume);
+
+static struct i2c_driver qcom_x1e_it8987_ec_i2c_driver = {
+	.driver = {
+		.name = "yoga-slim7x-ec",
+		.of_match_table = qcom_x1e_it8987_ec_of_match,
+		.pm = &qcom_x1e_it8987_ec_pm_ops
+	},
+	.probe = qcom_x1e_it8987_ec_probe,
+	.remove = qcom_x1e_it8987_ec_remove,
+	.id_table = qcom_x1e_it8987_ec_i2c_id_table,
+};
+module_i2c_driver(qcom_x1e_it8987_ec_i2c_driver);
+
+MODULE_DESCRIPTION("Lenovo Yoga Slim 7x Embedded Controller");
+MODULE_LICENSE("GPL");
-- 
2.51.0

